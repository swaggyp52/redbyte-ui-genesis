import { LogicTemplate } from "./LogicTypes";

export function exportLogicAsJson(template: LogicTemplate): string {
  return JSON.stringify(template, null, 2);
}

/**
 * Very simple, human-readable Verilog-style export.
 * Not meant to be fed to a real tool yet — this is for
 * teaching and copy/paste in docs/slides.
 */
export function exportLogicAsVerilogModule(
  template: LogicTemplate,
  moduleName: string = "redbyte_circuit"
): string {
  const lines: string[] = [];

  const inputs = template.nodes.filter((n) => n.type === "INPUT_TOGGLE");
  const outputs = template.nodes.filter((n) => n.type === "OUTPUT_LAMP");
  const internals = template.nodes.filter(
    (n) => n.type !== "INPUT_TOGGLE" && n.type !== "OUTPUT_LAMP"
  );

  const wireNameForNode = (nodeId: string, outIndex: number = 0) =>
    `n_${nodeId}_o${outIndex}`;

  const inputPorts = inputs.map((n) => n.id).join(", ");
  const outputPorts = outputs.map((n) => n.id).join(", ");

  lines.push(`// Auto-generated by RedByte OS`);
  lines.push(`module ${moduleName}(`);
  lines.push(`  input  ${inputPorts},`);
  lines.push(`  output ${outputPorts}`);
  lines.push(`);`);
  lines.push("");

  for (const node of template.nodes) {
    if (node.type === "INPUT_TOGGLE") continue;
    const maxOut = Math.max(0, node.outputs - 1);
    for (let o = 0; o <= maxOut; o++) {
      lines.push(`  wire ${wireNameForNode(node.id, o)};`);
    }
  }
  lines.push("");

  for (const node of internals) {
    const outWire = wireNameForNode(node.id, 0);

    if (node.type === "GATE_NOT") {
      const inputWire = findFirstInputWire(template, node.id) ?? "1'bx";
      lines.push(`  assign ${outWire} = ~${inputWire};`);
    } else if (node.type === "GATE_AND") {
      const [a, b] = findTwoInputWires(template, node.id);
      lines.push(`  assign ${outWire} = ${a} & ${b};`);
    } else if (node.type === "GATE_OR") {
      const [a, b] = findTwoInputWires(template, node.id);
      lines.push(`  assign ${outWire} = ${a} | ${b};`);
    } else if (node.type === "GATE_XOR") {
      const [a, b] = findTwoInputWires(template, node.id);
      lines.push(`  assign ${outWire} = ${a} ^ ${b};`);
    } else if (node.type === "CLOCK") {
      lines.push(
        `  // CLOCK ${node.id} is modeled as a time-varying signal in the simulator,`
      );
      lines.push(
        `  // but here we leave it as an external input or a testbench-controlled wire.`
      );
    } else {
      lines.push(
        `  // Node ${node.id} of type ${node.type} is not expanded yet in this export.`
      );
    }
  }

  lines.push("");

  for (const outNode of outputs) {
    const inputWire = findFirstInputWire(template, outNode.id);
    const portName = outNode.id;
    const src = inputWire ?? "1'bx";
    lines.push(`  assign ${portName} = ${src};`);
  }

  lines.push("");
  lines.push("endmodule");
  lines.push("");

  return lines.join("\n");
}

function findFirstInputWire(template: LogicTemplate, nodeId: string): string | null {
  const wire = template.wires.find((w) => w.toNodeId === nodeId);
  if (!wire) return null;
  return `n_${wire.fromNodeId}_o${wire.fromIndex}`;
}

function findTwoInputWires(
  template: LogicTemplate,
  nodeId: string
): [string, string] {
  const wires = template.wires.filter((w) => w.toNodeId === nodeId);
  const a = wires[0]
    ? `n_${wires[0].fromNodeId}_o${wires[0].fromIndex}`
    : "1'bx";
  const b = wires[1]
    ? `n_${wires[1].fromNodeId}_o${wires[1].fromIndex}`
    : "1'bx";
  return [a, b];
}

